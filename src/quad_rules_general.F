C-----------------------------------------------------------------------
C
C     Subroutine quad_rules_general
C
C     Written by Dylan Wood (03-10-2017)
C
C     This subroutine returns the points of a n point quadrature rule 
C     for the 1-dimensional domain -1 to 1, via Golub-Welsch algorithm.
C     Legendre weights are determined from algebraic formulas.
C     Jacobi weights are computed from Gaussian elimination.
C
C     Quadrature type/weight function is Jacobi and determined from 
C     input values of alpha and beta.
C     A logical input indicates whether Lobatto rules are desired.
C
C-----------------------------------------------------------------------
C
C     Input:
C     ------
C       n:       Number of quadrature points/weights desired.
C       lobatyn: Logicial value indicating whether a Lobatto type rule
C                 is desired, i.e. rule including the endpoints -1 and 1
C                 as quadrature points.
C       alph:    Value for alpha in Jacobi weight, 
C                  (1 - x)**alpha*(1 + x)**beta.
C       bet:     Value for beta in Jacobi weight.
C
C       If alph = bet = 0 and lobatyn = .false.,
C          then a Gauss-Legendre type rule is generated.
C       If either alph or bet does not equal 0, and lobatyn = .false.,
C          then a Gauss-Jacobi type rule is generated.
C       If lobatyn = .true.,
C          then alph and bet MUST BOTH equal 0 for a quadrature rule to
C          be generated by this subroutine. In this case the rule is of 
C          type Gauss-Legendre-Lobatto.
C       Gauss-Jacobi-Lobatto rules are not currently generated by this
C        subroutine.
C
C     Output:
C     -------
C       pts: Array of quadrature points of size n by 1
C       wts: Array of quadrature weights of size n by 1.
C
C-----------------------------------------------------------------------
      subroutine quad_rules_general(n, lobatyn, alph, bet, pts, wts)

      implicit none

      integer n,np1,nm1,nin
      logical, intent(in) :: lobatyn
      integer j,m,quadtype,nn,p,ierr,i
      real(8), intent(in) :: alph, bet
      real(8), dimension(n), intent(out) :: pts, wts
      real(8), dimension(n) :: aj, bj
      real(8) :: Jac(n,n), augJ(n+1,n), eig(n), v(n)
      real(8), dimension(0:n+1) :: polyo
      real(8) eps, jrl, dum, ajp1, bjp1, x, prl,nv,lambda
      real(8) summ, dpolyon, al, be, nrl,B0, gammaf

c.....Determine whether Lobatto rules are needed. If so, 
c.....prepare elements for modified Jacobi matrix, and
c.....places these elements in the necessary locations.
      if (lobatyn) then
         al = alph
         be = bet
         if (.not.(alph.eq. 0.0d0 .and.bet.eq. 0.0d0)) then
            PRINT*,' ERROR ENCOUNTERED IN quad_rules_general.f! '
            PRINT*,' INVALID CHOICE(S) FOR ALPHA/BETA FOR QUADRATURE! '
            PRINT*,' IF LOBATTO RULES ARE NEEDED, CURRENTLY ONLY '
            PRINT*,' LEGENDRE WEIGHTS ARE SUPPORTED FOR THESE RULES '
            PRINT*,' NOW SETTING ALPHA = BETA = 0. '
            al = 0.0d0 
            be = 0.0d0
            PRINT*,' CONTINUING EXECUTION. '
         endif

         n = n - 1
         nn = n - 1
         nrl = real(nn, kind=8)
         Jac(:,:) = 0.0d0
         ajp1 = (al - be)/(2.0d0*nrl + al + be + 2.0d0)
         bjp1 = 4.0d0*(nrl + al + 1.0d0)*(nrl + be + 1.0d0)
     &      *(nrl + al + be + 1.0d0)
     &      /((2.0d0*nrl + al + be + 1.0d0)
     &      *(2.0d0*nrl + al + be + 2.0d0)
     &      *(2.0d0*nrl + al + be + 2.0d0))
            bjp1 = sqrt(bjp1)
         Jac(n+1,n+1) = ajp1
         Jac(n,n+1) = bjp1
         Jac(n+1,n) = bjp1
         nn = n + 1
            
      else
         al = alph
         be = bet
         Jac(:,:) = 0.0d0
         nn = n
      endif

c.....Determine whether Legendre or Jacobi weights are desired and
c.....calculate entries of Jacobi matrix accordingly.
      if (al .eq. 0.0d0 .and. be .eq. 0.0d0) then
         quadtype = 1
         aj(1:n) = 0.0d0
         do j = 1, n-1
            jrl = real(j, kind=8)
            bj(j) = jrl*jrl/(4.0d0*jrl*jrl - 1.0d0)
         enddo
      elseif (al .gt. -1.0d0 .and. be .gt. -1.0d0) then
         quadtype = 2
         do j = 1, n
            jrl = real(j, kind=8)
            dum = 2.0d0*jrl + al + be
            aj(j) = (be - al) * (be + al) / (dum * (dum - 2.0d0))   
         enddo
         do j = 1, n-1
            jrl = real(j, kind=8)
            dum = 2.0d0*jrl + al + be
            bj(j) = 4.0d0*jrl * (al + jrl) 
     &         * (be + jrl) * (al + be + jrl) 
     &         / (dum*dum*(dum + 1.0d0)*(dum - 1.0d0))
         enddo
      else
         PRINT*,' ERROR ENCOUNTERED IN quad_rules_general.f! '
         PRINT*,' INVALID CHOICE(S) FOR ALPHA/BETA FOR QUADRATURE! '
         PRINT*,' ALPHA AND BETA MUST BOTH BE GREATER THAN -1! '
         PRINT*,' EXECUTION TERMINATED IN SUBROUTINE
     & quad_rules_general. '
         STOP
      endif
      bj(n) = 0.0d0
      bj(1:n) = sqrt(bj(1:n))

C.....Construct Jacobi matrix
      do j = 1,n
         Jac(j,j) = aj(j)
      enddo
      do j = 2,n
         Jac(j,j-1) = bj(j-1)
         Jac(j-1,j) = bj(j-1)
      enddo

C.....Determine machine precision
      eps = epsilon(aj(1))

C.....Find eigenvalues of Jacobi matrix via QR iteration                  
      call QRdecomp(Jac,nn,eps,eig)

C.....If rule is symmetric, duplicate values across the symmetry.
      if (al .eq. be) then
         if (mod(nn,2) .eq. 1) then
            m = ceiling(real(nn, kind=8)/2.d0)
            pts(1:m) = eig(1:m)
            pts(m+1:nn) =  -pts(m-1:1:-1)
         else
            m = nn/2
            pts(1:m) = eig(1:m)
            pts(m+1:nn) = -pts(m:1:-1)
         endif
      else
         pts(:) = eig(:)
      endif

C.....If a point is very close to 0, then set it equal to 0.
      do j = 1,nn
         if (abs(pts(j)).LT. 1.0d-12) pts(j) = 0.0d0
      enddo
C.....If Lobatto endpoints are close to 1 in absolute value, then
C.....set endpoints equal to 1.
      if (lobatyn) then
         if (abs(pts(1) - (-1.0d0)).LT. 1.0d-12) pts(1) = -1.0d0
         if (abs(pts(nn) - 1.0d0).LT. 1.0d-12) pts(nn) = 1.0d0
      endif

C.....Find weights from algebraic formulas
      do m = 1,nn
         x = pts(m)
         if (quadtype .eq. 1 .and. .not. lobatyn) then
C...........Legendre weights
            polyo(0)  = 1.0d0
            polyo(1)  = x
C...........Compute values of Legendre polys. at current point from
C...........recurrence relation.
            do p = 1,n
               prl = real(p, kind=8)
               polyo(p+1) = ((2.0d0*prl+1.0d0)*x*polyo(p)-prl
     &            *polyo(p-1))/(prl+1.0d0)
            enddo
C...........Compute weights
            nrl = real(n, kind=8)
            wts(m) = 2.0d0*(1.0d0 - x*x)/((nrl + 1.0d0)*(nrl + 1.0d0)
     &         *polyo(n+1)*polyo(n+1))
         elseif (quadtype .eq. 2 .and. .not. lobatyn) then
C...........Jacobi weights, computed from eigenvectors, which are
C...........computed by Guassian elimination.
            lambda = pts(m)

            do j = 1,nn
               do i = 1,nn
                  augJ(i,j) = Jac(i,j)
               enddo
               augJ(j,j) = augJ(j,j) - lambda
               augJ(nn+1,j) = 0.0d0
            enddo

            call Gauss_Elim(augJ,nn,ierr)

            v = augJ(nn+1,:)

            summ = 0.0d0
            do j = 1,nn
               summ = summ + v(j)*v(j)
            enddo
            nv = sqrt(summ)

            if (abs(nv).LT. eps) nv = eps
            v = v/nv

            B0 = 2.0d0**(alph + bet + 1.0d0) 
     &         * gammaf(alph + 1.0d0) * gammaf(bet + 1.0d0) 
     &         / gammaf(alph + bet + 2.0d0)
            wts(m) = B0*v(1)*v(1)

         elseif (lobatyn) then
            if (quadtype .eq. 1) then
C..............Lobatto rule weights with Lengendre weight function.
               nin = nn - 2
               nrl = real( nin, kind = 8)
               if (m .eq. 1) then
C..............Compute weights at endpoints.
                  wts(m) = 2.0d0/((nrl+1.0d0)*(nrl+2.0d0))
               elseif (m .eq. nn) then
                  wts(m) = wts(1)
               else
C..............Compute weights at interior quad points.
                  polyo(0)  = 1.0d0
                  polyo(1)  = x
C.................Compute values of Legendre polys. at current point 
C.................from recurrence relation.
                  do p = 1,nin
                     prl = real(p, kind=8)
                     polyo(p+1) = ((2.0d0*prl+1.0d0)*x*polyo(p)-prl
     &                  *polyo(p-1))/(prl+1.0d0)
                  enddo
C.................Compute weights
                  wts(m) = 2.0d0/((nrl+1.0d0)*(nrl+2.d0)
     &               *polyo(nin+1)*polyo(nin+1))
               endif
            elseif (quadtype .eq. 2) then
C..............This is where code for weights of Guass-Jacobi-Lobatto
C..............type rules would go. The author has no practical need
C..............for these rules, so they are currently excluded.
            endif                  
         endif

      enddo 
      if (lobatyn) then
         n = n + 1
      endif   

      end subroutine
   
      subroutine QRdecomp(A,n,eps,eig)
C.....QR decomposition with shifting
      implicit none
      integer, intent(in)::n
      integer i,k
      real(8), dimension(n,n), intent(in):: A
      real(8), dimension(n,n) :: A2,oldA2,Q,QT,R,EYE
      real(8) res,sig,normA
      real(8), intent(in):: eps
      real(8), dimension(n) :: vec1,vec2
      real(8), dimension(n), intent(out)::eig
      logical DoIterate


      EYE(:,:) = 0.0d0
      do i = 1,n
         EYE(i,i) = 1.0d0
      enddo   

      oldA2(:,:) = 1.0d0
      A2(:,:) = A(:,:)

      do while (DoIterate(A2,oldA2,eps,n))
         sig = 0.0d0
         do i = 1,n
            normA = 0.0d0
            do k = 1,n
               normA = normA + A2(i,k)*A2(i,k)
            enddo
            normA = sqrt(normA)
            sig = max(normA,sig)
         enddo

         oldA2(:,:)=A2(:,:)
         A2(:,:) = A2(:,:) - sig*EYE(:,:)

         Q(:,:)=A2(:,:)
         do i=1,n
            do k=1,i-1
               vec1 = Q(:,i)
               vec2 = Q(:,k)
               call dotprod(vec1,vec2,n,res)
               Q(:,i)=Q(:,i)-res*Q(:,k)
            enddo
            call dotprod(Q(:,i),Q(:,i),n,res)
            if (abs(res).LT.eps) res = eps
            Q(:,i)=Q(:,i)/sqrt(res)
         enddo
         QT=transpose(Q)
         R=matmul(QT,A2)
         A2=matmul(R,Q) + sig*EYE(:,:)
      enddo
   
      do i=1,n
         eig(i)=A2(i,i)
      enddo
      end subroutine
      
      function gammaf(n)
      ! Compute the gamma function for an input
      implicit none
      real(8), intent(in) :: n
      integer :: i, m
      real(8) :: ans, gammaf
      
      ! Subtract 1 from input number (should be an integer as a real)
      m = int(n - 1.0d0)
      ans = 1.0d0
      ! Calculate the factorial of n-1
      do i = 1,m
         ans = ans * dble(i)
      end do
      gammaf = ans
      return
      
      end function

      subroutine dotprod(vec1,vec2,n,prod)
      ! Compute the dot product of two vector inputs
      implicit none
      integer::n,i
      real(8), dimension(n)::vec1,vec2
      real(8)::prod
      prod=0.0d0
      do i=1,n
         prod=prod+vec1(i)*vec2(i)
      enddo
   
      end subroutine

      function DoIterate (A1,A2,eps,n)
      ! Evaluate whether or not to iterate QR decomp.
      implicit none
      integer::n,i,j
      real(8), dimension(n,n)::A1,A2
      real(8)::eps
      logical::DoIterate

      DoIterate=.false.
      do i=1,n
         do j=1,n
            if (abs(abs(A1(i,j))-abs(A2(i,j))) .gt.eps) then
               DoIterate=.true.
               exit
            endif
         enddo
      enddo
      return

      end function

      subroutine Gauss_Elim(M,n,ierr)
      ! Perform Gaussian elimination on an "augmented matrix"
      implicit none
      integer, intent(in)::n
      integer, intent(out)::ierr
      real(8), dimension(n+1,n), intent(inout)::M
      real(8)::tempM,val,eps
      integer::i,j,k,c,a,b,temp
      logical::broken

      eps = 1.0d-8
      broken=.false.
      ierr=0
      do i=1,n
         temp=i
         val=abs(M(i,i))
         do k=i+1,n
            if (val .lt. abs(M(i,k))) then
               val=abs(M(i,k))
               temp=k
            end if
         end do
         if (temp .ne. i) then
            do k=i,n+1
               tempM=M(k,i)
               M(k,i)=M(k,temp)
               M(k,temp)=tempM
            end do
         end if
         val=M(i,i)
         if (abs(val) .lt. eps) then
            broken=.true.
            exit
         end if
         do k=i,n+1
            M(k,i)=M(k,i)/val
         end do
         do c=i+1,n
            val=M(i,c)
            do k=i,n+1
               M(k,c)=M(k,c)-val*M(k,i)
            end do
         end do
      end do

      if (broken) then
         ierr=-i
         do a=i,n+1
            do b=i,n
               if (abs(M(a,b)) .gt. eps) then
                  ierr=a
                  return
               end if
               M(a,b)=0.0d0
            end do
         end do
         do b=i,n
            M(b,b)=1.0d0
            M(n+1,b)=real(n-b+1, kind=8)    
         end do
      end if

      do i=n,1,-1
         do j=i-1,1,-1
            M(n+1,j)=M(n+1,j)-M(i,j)*M(n+1,i)
            M(i,j)=M(i,j)-M(i,j)*M(i,i)
         end do
      end do

      end subroutine
